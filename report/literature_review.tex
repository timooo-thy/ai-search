\chapter{Literature Review}

New developers often struggle with understanding new and unfamiliar codebases, leading to prolonged onboarding times and reduced productivity. Various strategies have been proposed to address this challenge such as improved documentation practices. However, these methods often fall short in providing comprehensive and efficient solutions for code comprehension. The rise in adoption of AI-assisted tools has introduced new challenges. One key challenge is that these tools hallucinate information that is often not grounded in actual source code. Furthermore, large codebases make it harder for LLMs to comprehend due to its limited context window.

This literature review examines five interrelated research domains critical to CodeOrient, an AI Search Tool for code comprehension:

\begin{enumerate}
    \item Software Complexity Metrics and Code Quality Measurements
    \item Semantic Code Search and Natural Language Query Processing
    \item AI Hallucination and Grounded Code Comprehension
    \item Code Visualisation and Dependency Analysis
    \item Generative User Interfaces
\end{enumerate}
The combination of these areas provides the theoretical foundation for building an AI application that reduces developer onboarding time while ensuring the generated explanations are accurate and grounded in the actual codebase.

\section{Software Complexity Metrics and Code Quality Measurements}

\subsection{Cyclomatic Complexity as Foundation}
Thomas J.McCabe introduced cyclomatic complexity, a quantitative measure of program complexity based on control graph flow analysis \cite{mccabe1976}. His work established that cyclomatic complexity directly correlates with code maintainability and testing. The formula $M=E-N+2P$, where $E$ represents edges, $N$ represents nodes, and $P$ represents the number of connected components in a control flow graph, represents the complexity as the number of linearly independent paths through a programâ€™s source code \cite{mccabe1976}. As shown in \textit{Figure~\ref{fig:control_flow_graph}}, a simple control flow graph of a function below yields a complexity of 2, where $P=1$.

\begin{figure}[H]
    \centering
    {\small
    \includegraphics[width=3in]{fig/fig1.png}
    \caption{\textit{Control flow graph of a simple if-else statement.}}
    \label{fig:control_flow_graph}
    }
\end{figure}

McCabe's complexity measure allows developers to identify highly complex functions and recognise problematic code sections that require refactoring. When implementing the code graph visualisation feature in a code search application, cyclomatic complexity serves as one signal among many to highlight high-risk or critical code sections. 

\subsection{Modern Complexity in Distributed Systems}
Kafura's recent reflection on McCabe's work in 2025 acknowledges that cyclomatic complexity has proven durable for the last 50 years. However, modern software architectures, such as distributed systems and microservices, require additional metrics beyond control flow analysis \cite{kafura2025}. This observation showcases the potential of integrating graph visualisation into modern AI assistants to help developers understand not just function-level complexity but also system-level interactions.

\section{Code Search and Natural Language Query Processing}

\subsection{Semantic Code Search Through Embeddings}
Code search has evolved from simple keyword matching to more sophisticated semantic search techniques. Cambronero et al. explored the use of neural embeddings for semantic code search \cite{cambronero2019}. Their approach involves training models to transform both code snippets and natural language queries into a shared vector space \cite{cambronero2019}. Similar code snippets can be retrieved by calculating the cosine similarity between their embedding vectors. Cambronero et al. demonstrated that the use of neural embeddings could bridge the semantic gap between natural language queries and code snippets \cite{cambronero2019}. By transforming both code and queries into a shared vector space, code snippets relevant to the query can be retrieved by calculating the cosine similarity between their embedding vectors, given by the formula:
\[
\text{cosine\_similarity}(\vec{a}, \vec{b}) = \frac{\vec{a} \cdot \vec{b}}{\|\vec{a}\| \|\vec{b}\|}
\]
where $\vec{a}$ and $\vec{b}$ are the embedding vectors of the query and code snippet, respectively.

\textit{Figure~\ref{fig:semantic_code_search}} showcases how a query is transformed into an embedding vector which shares the same embedding space as code snippets. Although this technique does not replace traditional code search, it complements traditional methods that often miss semantically relevant results.

\begin{figure}[H]
    \centering
    {\small
    \includegraphics[width=5.5in]{fig/fig2.png}
    \caption{\textit{Semantic code search in a shared embedding space for retrieval \cite{cambronero2019}.}}
    \label{fig:semantic_code_search}
    }
\end{figure}

\subsection{Structural Code Search with Domain-Specific Languages}
Recent research conducted in 2025 explored structural code search techniques using Domain-Specific Languages (DSLs). Limpanukorn et al. proposed translating natural language queries into DSL queries which capture the structural relationships within a codebase, which goes beyond mere semantic similarity \cite{limpanukorn2025}. Their approach achieved a precision score of 55-70\% and outperformed semantic search baselines by up to 57\% on F1 scores \cite{limpanukorn2025}.

This research presents a critical missing link in developer tools, such as tracing an ``authentication flow'', where the relationships between modules are more informative than the functions' names themselves. Their findings highlight the need for code graph visualisation to represent these structural relationships effectively.

\subsection{Retrieval using Code Embedding Models}
Qodo introduced specialised code embedding models (Qodo Embed-1) that achieved state-of-the-art performance (product score of 3.72/5) in Codebase Understanding Gartner{\textregistered} in 2025 \cite{tai2025}. Their approach bypasses the intermediate language description step. Instead, their models directly encode code semantics, resulting the models to be computationally efficient while maintaining high retrieval accuracy for code search tasks \cite{tai2025}. 

\section{AI Hallucination and Grounded Code Comprehension}

\subsection{The Hallucination Problem in LLMs}
With the increased adoption of AI-assisted code generation tools like GitHub Copilot and ChatGPT, the risk of hallucination has become a critical concern. Hallucination in code generation refers to the generation of code that appears correct but is actually non-functional. In 2025, Spracklen et al. conducted a comprehensive study on hallucination in code-generating LLMs \cite{spracklen2025} and found that package hallucinations are a systemic issue across state-of-the-art code-generating models. Their research included analysing over 576,000 code samples generated by 16 different LLMs. Their findings revealed that LLMs consistently hallucinate package names, and more worryingly, they regenerate the same false package name in 43\% of repeated prompts \cite{spracklen2025}.

In an agentic workflow where LLMs autonomously generate and execute code, hallucinations can be exploited by attackers via ``slopsquatting'', which is the practice of creating malicious packages with names similar to popular ones \cite{spracklen2025}. \textit{Figure~\ref{fig:hallucination_exploit}} showcases how an attacker can exploit hallucinations from LLMs. This research highlights the urgent need for citation-grounded code comprehension systems that can verify all claims against actual source code.

\begin{figure}[H]
    \centering
    {\small
    \includegraphics[width=2.5in]{fig/fig3.png}
    \caption{\textit{Exploiting LLM hallucinations through slopsquatting.}}
    \label{fig:hallucination_exploit}
    }
\end{figure}

\subsection{Citation-Grounded Code Comprehension}
Arafat et al.'s recent work on citation-grounded code comprehension directly addresses the hallucination problem \cite{arafat2025}. They conclude that code comprehension systems must ground all claims in verifiable source code citations. Their proposed hybrid retrieval system with Neo4j graph database to provide import relationships, achieved a 92\% citation accuracy with zero hallucinations. Moreover, the graph component discovered richer cross-file relationships that purely text-based retrieval missed, 62\% of architectural queries \cite{arafat2025}.

\subsection{Retrieval-Augmented Generation}
The broader principle emerging from hallucination research is Retrieval-Augmented Generation (RAG). As it is not possible to train new information into LLMs at scale, RAG provides a mechanism to ground LLM outputs with real-time data via a retriever \cite{ayala2024}. The use of a retriever reduced hallucination rates across all categories from a baseline high of 21\% to below 7.5\% \cite{ayala2024}. In the context of code comprehension, RAG refers to a retriever that fetches relevant code snippets, which are then passed to an LLM as a context to generate grounded explanations with source citations.

\begin{figure}[H]
    \centering
    {\small
    \includegraphics[width=5in]{fig/fig4.png}
    \caption{\textit{Retrieval-Augmented Generation to reduce hallucinations \cite{arafat2025}.}}
    \label{fig:rag_model}
    }
\end{figure}

\section{Code Visualisation and Dependency Analysis}

\subsection{Static Analysis and Dependency Graphs}
To understand the real structure of a codebase, dependency graphs are essential. Using entities as nodes and relationships as edges, code graphs provide a visual representation of how different components interact with each other \cite{jit2025}. The lack of visualisation makes it difficult for developers to grasp the complex relationship that are present in modern software architectures. This motivates CodeOrient's code graph visualisation feature to help developers trace data flows across multiple modules, functions, and files. 

\subsection{Interactive Visualisation Tools}
Among many code visualisation libraries, React Flow stands out for its interactivity and ease of integration with React applications \cite{jovanov2025}. React Flow allows developers to create interactive visualisations of code relationships. Rather than traditional large static diagrams, developers can pan and hover over nodes to reveal additional information, which is crucial for understanding complex codebases.

\section{Generative User Interface (UI)}

\subsection{Adaptive and Dynamic Interfaces}
Generative UI is an emerging field research by Google that focuses on using LLMs to generate dynamic UIs \cite{leviathan2025}. This extends the capability of text-based LLMs to generate UIs using task-driven data models \cite{cao2025}. Different queries will produce different UIs at runtime, allowing for highly personalised and adaptive interfaces. Their research shifts away from generating UI code snippets towards generating UI data models that is more aligned with user intent \cite{cao2025}. This approach directly motivates the use of Generative UI by rendering UI components instead of text-based responses in CodeOrient.

\section{Research Gaps and Motivation}
The reviewed literature highlights several advancements in software complexity metrics, semantic code search, hallucination mitigation, code visualisation, and Generative UI. However, there has been limited work in integrating these advancements into a cohesive system for developer onboarding. The following research gaps motivate the development of CodeOrient:

\subsection{Bridging Semantic and Structural Code Search}
Current tools typically favour either semantic search (finding code that looks right) or structural analysis (finding code that is connected). As noted by Limpanukorn et al. (2025), structural search outperforms semantic baselines, yet most AI tools like GitHub Copilot still rely primarily on text-based RAG. There is a lack of research into how Generative UI can bridge this gap by dynamically synthesising a visual graph that represents both the user's natural language intent and the codebase's physical architecture.

\subsection{The ``Black Box'' of Generative UI in Software Engineering}
Research by Leviathan et al. \cite{leviathan2025} and Cao et al. \cite{cao2025} establishes the framework for task-driven UIs. However, these studies focus on general tasks such as education or shopping, as shown in \textit{Figure~\ref{fig:generative_ui}}. In the high-stakes domain of software engineering, it is unknown how a constantly changing, generative interface affects a developer's productivity. CodeOrient will serve as an experimental platform to explore whether Generative UI can effectively reduce cognitive load and accelerate code comprehension for developers.

\begin{figure}[H]
    \centering
    {\small
    \includegraphics[width=5.5in]{fig/fig5.jpeg}
    \caption{\textit{Generative UI for a Room Rug Visualiser \cite{leviathan2025}.}}
    \label{fig:generative_ui}
    }
\end{figure}

\section{Conclusion}
To improve developer onboarding, it is essential to address code comprehension at different levels. By integrating insights from software complexity metrics \cite{mccabe1976}, semantic code search \cite{cambronero2019}, hallucination mitigation \cite{arafat2025}, and Generative UI \cite{leviathan2025}, CodeOrient aims to accelerate developer onboarding while being reliable and grounded in actual source code.